<?xml version="1.0" encoding="utf-8"?>
<CredentialsDatabase>
  <Credentials UserType="Admin">
    <Username>TA</Username>
    <Password>wWHOKNYGomkmJg1ZBgYYog==</Password>
  </Credentials>
  <Credentials UserType="Customer">
    <Username>Chris</Username>
    <Password>RRKtEYjML3BDPDsD9YsAdQ==</Password>
  </Credentials>
  <Credentials UserType="Customer">
    <Username>Craig</Username>
    <Password>+BKH+koODwAO1G911y7B+Q==</Password>
  </Credentials>
  <Credentials UserType="Customer">
    <Username>Kiera</Username>
    <Password>pkheO58sgno716FnlU9JeQ==</Password>
  </Credentials>
</CredentialsDatabase>

















import struct
import re

# Original magic numbers and dimensions
magic_num1 = 0x4963
magic_num2 = 0x474d
version_num = 0x2
dim1 = 0x76
dim2 = 0x24

# Convert to bytes and reverse the order
# '<' indicates little-endian byte order.
# 'H' stands for short 16-bit integers
reversed_mag1 = struct.pack('<H', magic_num1)
reversed_mag2 = struct.pack('<H', magic_num2)
reversed_ver = struct.pack('<H', version_num)
reversed_dim1 = struct.pack('<B', dim1)
reversed_dim2 = struct.pack('<B', dim2)

final_rev_bytes = reversed_mag1 + reversed_mag2 + reversed_ver + reversed_dim1 + reversed_dim2


# Example data
img_data = """
[38;2;255;255;255m.
[38;2;255;255;255m-
[38;2;255;255;255m-
[38;2;255;255;255m-
[38;2;255;255;255m-
[38;2;255;255;255m-
[38;2;255;255;255m-
"""


# Pattern to capture ANSI escape sequences in bytes with optional trailing characters
pattern = re.compile(rb'\[38;2;(\d+);(\d+);(\d+)m(.)?')

# Function to process matches
def replacement(match):
    r, g, b, char = match.groups()
    # Convert RGB values to hexadecimal
    r_hex = f"{int(r):02X}".encode('ascii')
    g_hex = f"{int(g):02X}".encode('ascii')
    b_hex = f"{int(b):02X}".encode('ascii')

    # Construct the new byte sequence
    if char is None or char.isspace():  # No character or a whitespace
        return b'\x5B\x33\x38\x3B\x32\x3B' + r_hex + b';' + g_hex + b';' + b_hex + b'm\x5B\x30m'
    else:  # Visible character present
        return b'\x5B\x33\x38\x3B\x32\x3B' + r_hex + b';' + g_hex + b';' + b_hex + b'm' + char.encode('ascii') + b'\x5B\x30m'



#hexi = 1920
#non_space_pad = b'' #
#non_space_pad = non_space_pad + (b'\x8C\x1D\x40\x5C' * (hexi))


# Apply replacement to img_data using the pattern
result_string = pattern.sub(replacement, img_data)

# Remove any unwanted newlines
#result_string = result_string.replace("\n", "")

#print(result_string)



# Convert formatted result_string into bytes with the escape character
#result_bytes = result_string.encode('ascii')

# Add initial byte sequence with padding and result_bytes
final_bytes_with_padding = final_rev_bytes + result_bytes

# Write to a file
with open('magic_number.cimg', 'wb') as f:
    f.write(final_bytes_with_padding)

















































import struct
import re

# Original magic numbers and dimensions
magic_num1 = 0x4963
magic_num2 = 0x474d
version_num = 0x2
dim1 = 0x76
dim2 = 0x24

# Convert to bytes and reverse the order
# '<' indicates little-endian byte order.
# 'H' stands for short 16-bit integers
reversed_mag1 = struct.pack('<H', magic_num1)
reversed_mag2 = struct.pack('<H', magic_num2)
reversed_ver = struct.pack('<H', version_num)
reversed_dim1 = struct.pack('<B', dim1)
reversed_dim2 = struct.pack('<B', dim2)

final_rev_bytes = reversed_mag1 + reversed_mag2 + reversed_ver + reversed_dim1 + reversed_dim2



# Example data
img_data = b"""
[38;2;000;255;000m_
[38;2;000;255;000m|
[38;2;255;255;255m 
[38;2;000;000;255m|
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;000;000;255m\
[38;2;000;000;255m/
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;000;000;255m|
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;128;128;128m/
[38;2;255;255;255m 
[38;2;128;128;128m_
[38;2;128;128;128m_
[38;2;128;128;128m_
[38;2;128;128;128m|
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m|
[38;2;000;000;000m
[38;2;255;255;255m|
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;255;000;000m/
[38;2;255;255;255m 
[38;2;255;000;000m_
[38;2;255;000;000m_
[38;2;255;000;000m|
[38;2;255;255;255m 
[38;2;255;255;255m 
[38;2;000;255;000m|
[38;2;255;255;255m 
[38;2;000;255;000m|
[38;2;255;255;255m 
[38;2;255;255;255m 
"""




# Pattern to match ANSI sequences
pattern = re.compile(rb'\[38;2;(\d+);(\d+);(\d+)m(.)?')

# Function to process matches
def replacement(match):
    r, g, b, char = match.groups()

    # Convert RGB values to raw bytes (ensure they are exactly 1 byte each)
    r_byte = int(r).to_bytes(1, 'big')  # Convert R to a single byte
    g_byte = int(g).to_bytes(1, 'big')  # Convert G to a single byte
    b_byte = int(b).to_bytes(1, 'big')  # Convert B to a single byte

    # Construct the escape sequence entirely in bytes using hex byte representation
    prefix = b'\x5B\x33\x38\x3B\x32\x3B'  # [38;2;
    separator = b'\x3B'  # ;
    suffix = b'\x6D'  # m

    # Handle the trailing character
    if char is None or char.isspace():  # No character or whitespace
        return prefix + r_byte + separator + g_byte + separator + b_byte + suffix
    else:  # Visible character present
        char_byte = char  # Convert the character to raw bytes
        return prefix + r_byte + separator + g_byte + separator + b_byte + suffix + char_byte







# Apply replacement to img_data using the pattern
result_bytes = pattern.sub(replacement, img_data)

# Remove any unwanted newlines
result_bytes = result_bytes.replace(b'\n', b'')

print(result_bytes)



# Convert formatted result_string into bytes with the escape character
#result_bytes = result_string.encode('ascii')

# Add initial byte sequence with padding and result_bytes
final_bytes_with_padding = final_rev_bytes + result_bytes

# Write to a file
with open('magic_number.cimg', 'wb') as f:
    f.write(final_bytes_with_padding)